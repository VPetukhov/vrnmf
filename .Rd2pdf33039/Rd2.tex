\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `vrnmf'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Title]\AsIs{Volume-regularized structured matrix factorization.}
\item[Version]\AsIs{0.0.0.9000}
\item[Description]\AsIs{The package implements a set of routines to perform structured matrix factorization with minimum volume constraints.}
\item[Depends]\AsIs{R (>= 3.5.1)}
\item[License]\AsIs{GPL-3}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[RoxygenNote]\AsIs{7.1.0}
\item[Imports]\AsIs{ica (>= 1.0),
lpSolveAPI (>= 5.5.2.0),
quadprog (>= 1.5),
parallel (>= 3.5.1)}
\item[Suggests]\AsIs{knitr (>= 1.28),
rmarkdown (>= 2.1)}
\item[VignetteBuilder]\AsIs{knitr}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{AnchorFree}{Non-negative tri-factorization of co-occurence matrix using minimum volume approach.}{AnchorFree}
%
\begin{Description}\relax
\code{AnchorFree} method tri-factorizes (co-occurence) matrix in a product  \eqn{P ~ C*E*t(C)}{} of non-negative matrices \eqn{C}{} and \eqn{E}{}
such that matrix \eqn{E}{} has mininum volume and columns of matrix \eqn{C}{} equal to 1.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
AnchorFree(
  vol,
  n.comp = 3,
  init = NULL,
  init.type = "diag",
  n.iter = 30,
  err.cut = 1e-30,
  verbose = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vol}] An output object of \code{\LinkA{vol\_preprocess()}{vol.Rul.preprocess()}}. The method factorizes co-occurence matrix \code{vol\$P}.

\item[\code{n.comp}] An integer. Number of components to extract (by default 3). Defines number of columns in matrix \eqn{C}{}.

\item[\code{init}] A numeric matrix. Initial matrix \code{M} (by default \code{NULL}).

\item[\code{init.type}] A character. A strategy to randomly initialize matrix \code{M}. Options are to

1) generate diagonal unit matrix ("diag"),

2) use ICA solution as initialization ("ica", "ica.pos").

or sample entries from:

3) uniform distribution \code{[0,1]} ("unif.pos"),

4) unform distribution \code{[-1,1]},

5) uniform distribution \code{[0.9,1.1]} ("similar"),

6) normal distribution \code{N(0,1)}.

\item[\code{n.iter}] An integer. Number of iterations (by default 30).

\item[\code{err.cut}] A numeric. Relative error in determinant between iterations to stop algorithm (now is not used).

\item[\code{verbose}] A boolean. Print per-iteration information (by default FALSE)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Implementation closely follows (Fu X \emph{et al.}, IEEE Trans Pattern Anal Mach Intell., 2019).
\end{Details}
%
\begin{Value}
List of objects:

\code{C}, \code{E} Factorization matrices.

\code{Pest} Estimate of \code{vol\$P} co-occurence matrix \eqn{Pest = C*E*t(C)}{}.

\code{M}, \code{detM} auxiliary matrix \code{M} and its determinant.

\code{init.type} type of initialization of matrix \code{M} that was used.
\end{Value}
\inputencoding{utf8}
\HeaderA{factor\_intensities}{Infer a matrix of non-negative intensities in NMF with offset/nmf-offset.}{factor.Rul.intensities}
%
\begin{Description}\relax
\code{factor\_intensities} estimates a non-negative matrix \code{D} that optimizes the objective function \eqn{F = ||X - C*D - offset||^2}{},
where offset is either column-specific offset or a "1-rank nmf term": product of row vector and column vector
\end{Description}
%
\begin{Usage}
\begin{verbatim}
factor_intensities(
  C,
  X,
  fit.nmf = TRUE,
  fit.factor = FALSE,
  qp.exact = FALSE,
  n.iter = 200,
  qp.iter = 10,
  rel.error.cutoff = 1e-05,
  extrapolate = TRUE,
  extrapolate.const = TRUE,
  extrapolate.convex = FALSE,
  q.factor = 1,
  verbose = TRUE,
  n.cores = 1
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{C, X}] Numeric matrices.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Fitted matrix \code{D}.
\end{Value}
\inputencoding{utf8}
\HeaderA{infer\_intensities}{Infer a matrix of non-negative intensities in NMF}{infer.Rul.intensities}
%
\begin{Description}\relax
\code{infer\_intensities} estimates a non-negative matrix \code{D} that optimizes the objective function \eqn{F = ||X - C*D||^2}{}
using per-row quadratic programming.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
infer_intensities(C, X, esign = "pos", n.cores = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{C, X}] Numeric matrices.

\item[\code{esign}] A character. Keep elements of matrix \code{D} non-negative ("pos") or not ("all). By default "pos".

\item[\code{n.cores}] An integer. Number of cores to use (by default 1).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Fitted matrix \code{D}.
\end{Value}
\inputencoding{utf8}
\HeaderA{projection\_onto\_simplex}{Project vector onto a probabilistic simplex.}{projection.Rul.onto.Rul.simplex}
%
\begin{Description}\relax
\code{projection\_onto\_simplex} projects a vector \code{unproj} onto a probabilistic simplex of sum \code{bound}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projection_onto_simplex(unproj, bound)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unproj}] A numeric vector. An unprojected vector

\item[\code{bound}] A numeric. Sum of projected vector elements.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A projected vector.
\end{Value}
\inputencoding{utf8}
\HeaderA{simnmf}{Simulated example of noiseless non-negative matrix factorization.}{simnmf}
\keyword{datasets}{simnmf}
%
\begin{Description}\relax
A dataset containing original, noisy and decomposition matrices.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(simnmf)
\end{verbatim}
\end{Usage}
%
\begin{Format}
A list of 4 items.
\begin{description}

\item[X.noise] noise matrix
\item[X] original matrix
\item[C] left decomposition matrix
\item[D] right decomposition matrix

\end{description}

\end{Format}
%
\begin{Source}\relax
\url{web_link}
\end{Source}
\inputencoding{utf8}
\HeaderA{sim\_factors}{Simulate matrices to explores \code{vrnmf}}{sim.Rul.factors}
%
\begin{Description}\relax
\code{sim\_factors} simulates non-negative factorization matrices \code{C} and \code{D}
under a variaty of conditions to explore factorization \eqn{X = C*D + noise}{}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sim_factors(
  m,
  n,
  r,
  simplex = "col",
  distr = "unif",
  frac.zeros = 0.4,
  condition = FALSE,
  noise = 0
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{m, n, r}] Integers. Size of matrices. Matrix \code{C} has a size of \code{m*r}
and matrix \code{D} has a size of \code{r*n}.

\item[\code{simplex}] A character. Either columns ("col") or rows ("row") of matrix \code{C} are projected onto unit simplex.

\item[\code{distr}] A character. Distribution to simulate matrix entries: "unif" for uniform and "exp" for exponential distributions.

\item[\code{frac.zeros}] A numeric. Fraction of zeros in matrix \code{C}. It promotes sufficient scattering of matrix column/row vectors.

\item[\code{condition}] A boolean. Generate more well-conditioned matrix \code{R}.

\item[\code{noise}] A numeric. Standard deviation of gaussian noise to add.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
List of simulated matrices:

\code{X.noise}, \code{X} - noisy and original matrix \code{X} to decompose.

\code{C}, \code{D} - factorization matrices.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_det}{Update volume-regularized matrix \code{R} using det volume approximation}{volnmf.Rul.det}
%
\begin{Description}\relax
\code{volnmf\_det} finds matrix \code{R} that minimizes objective
\code{||X-C*R||\textasciicircum{}2 + w.vol*det(R)}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_det(
  C,
  X,
  R,
  posit = FALSE,
  w.vol = 0.1,
  eigen.cut = 1e-16,
  err.cut = 0.001,
  n.iter = 1000
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{C, X, R}] Numeric Matrices. Matrices involved in objective function.
Matrix R serves as initialization.

\item[\code{posit}] A boolean. Set up (TRUE) or not (FALSE) non-negative constraints on matrix \code{R} (by default FALSE).

\item[\code{w.vol}] A numeric. Volume (det) weight in objective function.

\item[\code{eigen.cut}] A numeric.

\item[\code{err.cut}] A numeric. Stop algorithm if relative erro in R between iteration is less than \code{err.cut}.

\item[\code{n.iter}] An integer. Number of iterations.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An updated matrix \code{R}.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_estimate}{Alternating optimization of volume-regularized NMF}{volnmf.Rul.estimate}
%
\begin{Description}\relax
\code{volnmf\_estimate} provides alternating optimization of volume-regularized factorization of a matrix \code{B} using the following objective function:
\eqn{F = ||B*Q - C*R||^2 + w.vol*volume(R)}{}. Matrix \code{C} is required to be non-negative and having either column or row vectors on the simplex.
Matrix \code{R} can optionally have non-negativity constraint. Matrix \code{Q} can optionally be identity matrix or any unitary.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_estimate(
  B,
  C,
  R,
  Q,
  domain = "covariance",
  volf = "logdet",
  R.majorate = FALSE,
  wvol = NULL,
  delta = 1e-08,
  n.iter = 10000,
  err.cut = 1e-08,
  vol.iter = 100,
  c.iter = 100,
  extrapolate = TRUE,
  accelerate = TRUE,
  acc.C = 4/5,
  acc.R = 3/4,
  C.constraint = "col",
  C.bound = 1,
  R.constraint = "pos",
  verbose = TRUE,
  record = 100,
  Canchor = NULL,
  Ctrue = NULL,
  mutation.run = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{B}] A numeric matrix. A matrix to factorize (by default NULL). If not given than matrix \code{B} is taken to be a square root decomposition of \eqn{vol$P = B*t(B)}{}.

\item[\code{C, R, Q}] Numeric matrices. Initial matrices for optimiztion.

\item[\code{domain}] A character. Optimize unitary rotation matrix \code{Q} ("covariance") or keep it as identity matrix (as in standard NMF). By default "covariance".

\item[\code{volf}] A character. Function that approximate volume. Can have values of "logdet" or "det" (by default "logdet").

\item[\code{R.majorate}] A boolean. Majorate logdet each iteration of \code{volnmf\_logdet()} (by default FALSE).

\item[\code{wvol}] A numeric. A weight of volume-regularized term \code{volume(R)}.

\item[\code{delta}] A numeric. Logdet regularization term \code{log(det(R) + delta)} (by default 1e-8).

\item[\code{n.iter}] An integer. Number of iterations (by default \code{1,000}).

\item[\code{err.cut}] A numeric. Relative error in determinant between iterations to stop algorithm (by default \code{1e-8}).

\item[\code{vol.iter}] An integer. Number of iterations to update volume-regularized matrix \code{R} at each alternating step.

\item[\code{c.iter}] An integer. Number of iterations to update simplex matrix \code{C} at each alternating step.

\item[\code{extrapolate}] A numeric. Do Nesterov extrapolation inside blocks of R and C optimization (by default TRUE).

\item[\code{accelerate}] A numeric. Do acceleration each update after R and C blocks estimated via Nesterov-like extrapolation.

\item[\code{acc.C}] A numeric. Acceleration parameter of matrix C.

\item[\code{acc.R}] A numeric. Acceleration parameter of matrix R.

\item[\code{C.constraint}] A character. Constraint either sum of columns ("col") or sum of rows ("row) to be equal to \code{C.bound} (By default "col").

\item[\code{C.bound}] A numeric. A simplex constraint on matrix C vectors.

\item[\code{R.constraint}] A character. Set up non-negativity ("pos") constraint on elements of \code{R} (by default "pos", alternative "no").

\item[\code{verbose}] A boolean. Print per-iteration information (by default FALSE)

\item[\code{record}] A numeric. Record parameters every 'record' iterations (by default \code{NULL}).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
List of objects:

\code{C, R, Q}, \code{E} Factorization matrices.

\code{iter, err} Number of iterations and relative per-iteration error \code{err} in matrix \code{C}.

\code{info.record} a list of objects that record and store state of matrices each \code{record} iterations.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_logdet}{Update volume-regularized matrix \code{R} using logdet volume approximation.}{volnmf.Rul.logdet}
%
\begin{Description}\relax
\code{volnmf\_logdet} finds matrix \code{R} that minimizes objective
\code{||X-C*R||\textasciicircum{}2 + w.vol*log(det(R)+delta)}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_logdet(
  C,
  X,
  R,
  R.constraint = "pos",
  majorate = FALSE,
  extrapolate = TRUE,
  qmax = 100,
  w.vol = 0.1,
  delta = 1,
  err.cut = 0.001,
  n.iter = 1000
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{C, X, R}] Numeric Matrices. Matrices involved in objective function.
Matrix R serves as initialization.

\item[\code{R.constraint}] A character. Set up ('pos') or not ('no') non-negative constraints on matrix \code{R} (by default 'pos').

\item[\code{majorate}] A boolean. Majorate logdet each iteration (by default FALSE).

\item[\code{extrapolate}] A boolean. Use Nesterov acceleration (by default FALSE, currently is not supported).

\item[\code{w.vol}] A numeric. Volume (logdet) weight in objective function.

\item[\code{delta}] A numeric. Determinant pseudocount in objective function.

\item[\code{err.cut}] A numeric. Stop algorithm if relative erro in R between iteration is less than \code{err.cut}.

\item[\code{n.iter}] An integer. Number of iterations.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An updated matrix \code{R}.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_main}{Volume-regularized NMF}{volnmf.Rul.main}
%
\begin{Description}\relax
\code{volnmf\_main} enables volume-regularized factorization of a matrix \code{B} using the following objective function:
\eqn{F = ||B*Q - C*R||^2 + w.vol*volume(R)}{}. Matrix \code{C} is required to be non-negative and having either column or row vectors on the simplex.
Matrix \code{R} can optionally have non-negativity constraint. Matrix \code{Q} can optionally be identity matrix or any unitary.
The latter option is used to decompose co-occurence matrix \code{vol\$P}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_main(
  vol,
  B = NULL,
  volnmf = NULL,
  n.comp = 3,
  n.reduce = n.comp,
  do.nmf = TRUE,
  iter.nmf = 100,
  domain = "covariance",
  volf = "logdet",
  wvol = NULL,
  delta = 1e-08,
  n.iter = 500,
  err.cut = 1e-16,
  vol.iter = 20,
  c.iter = 20,
  extrapolate = TRUE,
  accelerate = FALSE,
  acc.C = 4/5,
  acc.R = 3/4,
  C.constraint = "col",
  C.bound = 1,
  R.constraint = "pos",
  R.majorate = FALSE,
  C.init = NULL,
  R.init = NULL,
  Q.init = NULL,
  anchor = NULL,
  Ctrue = NULL,
  verbose = TRUE,
  record = 100,
  verbose.nmf = FALSE,
  record.nmf = NULL,
  mutation.run = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vol}] An output object of \code{\LinkA{vol\_preprocess()}{vol.Rul.preprocess()}}.

\item[\code{B}] A numeric matrix. A matrix to factorize (by default NULL). If not given than matrix \code{B} is taken to be a square root decomposition of \eqn{vol$P = B*t(B)}{}.

\item[\code{volnmf}] An output object of \code{volnmf.main}. An option is useful to re-estimate solution using different parameters (by default NULL).

\item[\code{n.comp}] An integer. Number of components to extract (by default 3). Defines number of columns in matrix \eqn{C}{}.

\item[\code{n.reduce}] An integer. Dimensional reduction of matrix B (number of columns) if taken as a square root decomposition of \code{vol\$P} (by default equal to \code{n.comp}).

\item[\code{do.nmf}] A boolean. Estimate standard solution with \code{w.vol=0} as initialization before applying volume regularization (by default \code{TRUE}).

\item[\code{iter.nmf}] An integer. Number of iterations to get solution with \code{w.vol=0} if the former requested (by default \code{1,000}).

\item[\code{domain}] A character. Optimize unitary rotation matrix \code{Q} ("covariance") or keep it as identity matrix (as in standard NMF). By default "covariance".

\item[\code{volf}] A character. Function that approximate volume. Can have values of "logdet" or "det" (by default "logdet").

\item[\code{wvol}] A numeric. A weight of volume-regularized term \code{volume(R)}.

\item[\code{delta}] A numeric. Logdet regularization term \code{log(det(R) + delta)} (by default 1e-8).

\item[\code{n.iter}] An integer. Number of iterations (by default \code{1,000}).

\item[\code{err.cut}] A numeric. Relative error in determinant between iterations to stop algorithm (by default \code{1e-8}).

\item[\code{vol.iter}] An integer. Number of iterations to update volume-regularized matrix \code{R} at each alternating step.

\item[\code{c.iter}] An integer. Number of iterations to update simplex matrix \code{C} at each alternating step.

\item[\code{extrapolate}] A numeric. Do Nesterov extrapolation inside blocks of R and C optimization (by default TRUE).

\item[\code{accelerate}] A numeric. Do acceleration each update after R and C blocks estimated via Nesterov-like extrapolation.

\item[\code{acc.C}] A numeric. Acceleration parameter of matrix C.

\item[\code{acc.R}] A numeric. Acceleration parameter of matrix R.

\item[\code{C.constraint}] A character. Constraint either sum of columns ("col") or sum of rows ("row) to be equal to \code{C.bound} (By default "col").

\item[\code{C.bound}] A numeric. A simplex constraint on matrix C vectors.

\item[\code{R.constraint}] A character. Set up non-negativity ("pos") constraint on elements of \code{R} (by default "pos", alternative "no").

\item[\code{R.majorate}] A boolean. Majorate logdet each iteration of \code{volnmf\_logdet()} (by default FALSE).

\item[\code{C.init, R.init, Q.init}] Numeric matrices. Initialization of matrices \code{C, R, Q} (by default \code{NULL}).

\item[\code{anchor}] An output object of \code{AnchorFree()}. Object is used optionally to initialize matrices (by default \code{NULL}).

\item[\code{verbose}] A boolean. Print per-iteration information (by default FALSE)

\item[\code{record}] A numeric. Record parameters every 'record' iterations (by default \code{NULL}).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
List of objects:

\code{C, R, Q} Factorization matrices.

\code{C.init, R.init, Q.init} Initialization matrices for volume-regularized optimization.

\code{C.rand, R.rand, Q.rand} Random initialization matrices for NMF optimization \code{(w.vol=0)}.

\code{rec} a list of objects that record and store state of matrices each \code{record} iterations.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_procrustes}{Procrustes algorithm estimates orthonormal transformation between two matrices.}{volnmf.Rul.procrustes}
%
\begin{Description}\relax
\code{volnmf\_procrustes} finds orthonormal matrix \code{Q} that minimizes objective
\code{||A-B*Q||\textasciicircum{}2}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_procrustes(A, B)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{A, B}] Numeric Matrices. Orthonormal transformation convert matrix \code{B} in matrix \code{A}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An optimal orthonormal tranformation matrix \code{Q}.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_simplex\_col}{Update of a matrix in NMF with equality contstraints on columns.}{volnmf.Rul.simplex.Rul.col}
%
\begin{Description}\relax
\code{volnmf\_simplex\_col} finds non-negative matrix \code{C} that minimizes the objective \code{||X-C*R||\textasciicircum{}2}
under constraints that columns of C equal to 1 using local approximation with extrapolation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_simplex_col(
  X,
  R,
  C.prev = NULL,
  bound = 1,
  extrapolate = TRUE,
  err.cut = 1e-10,
  n.iter = 10000,
  qmax = 100
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{X, R, C.prev}] Numeric Matrices. Matrices involved in the objective function.
Matrix \code{C.prev} serves as initialization (by default NULL).

\item[\code{bound}] A numeric. Equality constraint on columns of matrix \code{C} (by default 1).

\item[\code{extrapolate}] A boolean. Use extrapolation after local approximation (by default TRUE).

\item[\code{err.cut}] A numeric. Stop iterations if relative error between iterations is less than \code{err.cut} (parameter is not active now).

\item[\code{n.iter}] An integer. Number of iterations (by default 1,000).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An updated matrix \code{C}.
\end{Value}
\inputencoding{utf8}
\HeaderA{volnmf\_simplex\_row}{Update of a matrix in NMF with equality contstraints on rows.}{volnmf.Rul.simplex.Rul.row}
%
\begin{Description}\relax
\code{volnmf\_simplex\_row} finds non-negative matrix \code{C} that minimizes the objective \code{||X-C*R||\textasciicircum{}2}
under constraints that rows of C equal to 1 using per-row quadratic programming.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
volnmf_simplex_row(X, R, C.prev = NULL, meq = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{X, R, C.prev}] Numeric Matrices. Matrices involved in the objective function.
Matrix \code{C.prev} serves as initialization (by default NULL).

\item[\code{meq}] An integer 0 or 1. Require equality (\code{meq=1}) or inequality (\code{meq=0}) constratint on rows (by default 1).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An updated matrix \code{C}.
\end{Value}
\inputencoding{utf8}
\HeaderA{vol\_preprocess}{Preprocess the data for downstream volume analysis.}{vol.Rul.preprocess}
%
\begin{Description}\relax
\code{vol\_preprocess} Routine normalizes the data (as requested), estimates covariance and SVD decomposition.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
vol_preprocess(X, col.norm = "sd", row.norm = NULL, pfactor = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{X}] A numeric matrix. Covariance is estimated for column vectors of \code{X}.

\item[\code{col.norm}] A character. Specifies column normalization strategy (by default "sd"). NULL to avoid normalization.

\item[\code{row.norm}] A character. Specifies row normalization strategy (by default NULL).

\item[\code{pfactor}] A numeric A factor to normalize co-occurence matrix (by default NULL).
Row normalization follows column normalization. NULL to avoid normalization.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of objects that include normalized matrix \code{X.process}, row and column normalization factors \code{row.factors} and \code{col.factors},
covariance matrix \code{P0}, covariance matrix \code{P} normalized to maximum value \code{pfactor},
orthonormal basis \code{U} and vector of eigenvalues \code{eigens}.
\end{Value}
\printindex{}
\end{document}
